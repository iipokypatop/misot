<?php
/**
 * Created by PhpStorm.
 * User: p.semenyuk
 * Date: 05.07.2015
 * Time: 2:47
 */

namespace AotTest\Functional\Sviaz\Processor;


use Aot\Sviaz\SubSequence;
use MivarTest\PHPUnitHelper;

use Aot\RussianMorphology\ChastiRechi\ChastiRechiRegistry as ChastiRechiRegistry;

use Aot\RussianMorphology\ChastiRechi\MorphologyRegistry;
use \Aot\Sviaz\Sequence as Sequence;
use Aot\Sviaz\Role\Registry as RoleRegistry;


use Aot\Sviaz\Rule\AssertedLink\Builder\Base as AssertedLinkBuilder;

use Aot\RussianMorphology\ChastiRechi\Glagol\Base as Glagol;


use Aot\RussianMorphology\ChastiRechi\Predlog\Base as Predlog;
use Aot\RussianMorphology\ChastiRechi\Prilagatelnoe\Base as Prilagatelnoe;
use Aot\RussianMorphology\ChastiRechi\Soyuz\Base;
use Aot\RussianMorphology\ChastiRechi\Suschestvitelnoe\Base as Suschestvitelnoe;
use Aot\RussianMorphology\ChastiRechi\Suschestvitelnoe\Morphology\Padeszh\Base as SuschestvitelnoePadeszhBase;
use Aot\RussianSyntacsis\Punctuaciya\Zapiataya;

use Aot\Sviaz\Rule\AssertedLink\AssertedMatching\MorphologyMatchingOperator\Eq;
use Aot\Sviaz\Rule\AssertedLink\Checker\Registry as LinkCheckerRegistry;
use Aot\Sviaz\Rule\AssertedMember\Checker\Registry as MemberCheckerRegistry;
use Aot\Sviaz\Rule\AssertedMember\PositionRegistry;


class SequenceTest extends \AotTest\AotDataStorage
{
    public function getMock(
        $originalClassName,
        $methods = array(),
        array $arguments = array(),
        $mockClassName = '',
        $callOriginalConstructor = false,
        $callOriginalClone = true,
        $callAutoload = true,
        $cloneArguments = false,
        $callOriginalMethods = false,
        $proxyTarget = null
    ) {
        return parent::getMock($originalClassName, $methods, $arguments, $mockClassName, $callOriginalConstructor,
            $callOriginalClone, $callAutoload, $cloneArguments,
            $callOriginalMethods); // TODO: Change the autogenerated stub
    }

    /**
     * Элемент не попал ни в одну подпоследовательность (не может такого быть)
     */
    public function testFindSubSequencesForMemberInNothing()
    {
        $sequence = \Aot\Sviaz\Sequence::create();///<Создаём последовательность
        $sub_sequence[0]=\Aot\Sviaz\SubSequence::create($sequence,0,1);
        $sub_sequence[1]=\Aot\Sviaz\SubSequence::create($sequence,3,4);
        $sub_sequence[2]=\Aot\Sviaz\SubSequence::create($sequence,4,6);
        $sequence->setSubSequence($sub_sequence);

        //Забиваем последовательность элементами
        for ($i=0;$i<2;$i++)
        {
            $member=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
            $sequence->append($member);
        }
        //Вставляем элемент, который будем искать
        $member_search=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
        $sequence->append($member_search);
        //забиваем последовательность элементами после искомого элемента
        for ($i = 3; $i <= 6; $i++)
        {
            $member=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
            $sequence->append($member);
        }


        $this->assertEquals(0,count($sequence->findSubSequencesForMember($member_search)));
    }

    /**
     * Элемент попал в одну подпоследовательность
     */
    public function testFindSubSequencesForMemberInOneSubSequence()
    {
        $sequence = \Aot\Sviaz\Sequence::create();///<Создаём последовательность
        $length_sequence_part_1=5;///< Количество элементов минус один до того элемента, который потом будем искать
        $length_sequence_part_2=10;///<Всего элементов, включая искомый элемент
        $sub_sequence[0]=\Aot\Sviaz\SubSequence::create($sequence,0,$length_sequence_part_1-2);
        $sub_sequence[1]=\Aot\Sviaz\SubSequence::create($sequence,$length_sequence_part_1-2,$length_sequence_part_1+2);
        $sub_sequence[2]=\Aot\Sviaz\SubSequence::create($sequence,$length_sequence_part_1+2,$length_sequence_part_2);
        $sequence->setSubSequence($sub_sequence);

        //Забиваем последовательность элементами
        for ($i=0;$i<$length_sequence_part_1;$i++)
        {
            $member=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
            $sequence->append($member);
        }
        //Вставляем элемент, который будем искать
        $member_search=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
        $sequence->append($member_search);
        //забиваем последовательность элементами после искомого элемента
        for ($i=$length_sequence_part_1+1;$i<$length_sequence_part_2;$i++)
        {
            $member=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
            $sequence->append($member);
        }


        $this->assertEquals(1,count($sequence->findSubSequencesForMember($member)));

    }

    /**
     * Элемент попал в две подпоследовательности
     */
    public function testFindSubSequencesForMemberInTwoSubSequence()
    {
        $sequence = \Aot\Sviaz\Sequence::create();///<Создаём последовательность
        $sub_sequence[0]=\Aot\Sviaz\SubSequence::create($sequence,0,2);
        $sub_sequence[1]=\Aot\Sviaz\SubSequence::create($sequence,2,4);
        $sub_sequence[2]=\Aot\Sviaz\SubSequence::create($sequence,4,5);
        $sequence->setSubSequence($sub_sequence);

        //Забиваем последовательность элементами
        for ($i=0;$i<2;$i++)
        {
            $member=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
            $sequence->append($member);
        }
        //Вставляем элемент, который будем искать
        $member_search=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
        $sequence->append($member_search);
        //забиваем последовательность элементами после искомого элемента
        for ($i=3;$i<=5;$i++)
        {
            $member=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
            $sequence->append($member);
        }


        $this->assertEquals(2,count($sequence->findSubSequencesForMember($member_search)));
    }

    /**
     * Получение позиции существующего элемента
     */
    public function testGetPositionOfExistMember()
    {
        $sequence = \Aot\Sviaz\Sequence::create();///<Создаём последовательность
        //Забиваем последовательность элементами
        $index_of_member=2;
        for ($i=0;$i<$index_of_member;$i++)
        {
            $member=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
            $sequence->append($member);
        }
        $member_search=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
        $sequence->append($member_search);
        $this->assertEquals($index_of_member,$sequence->getPosition($member_search));
    }

    /**
     * Получение позиции не существующего элемента
     */
    public function testGetPositionOfNorExistMember()
    {
        $sequence = \Aot\Sviaz\Sequence::create();///<Создаём последовательность
        //Забиваем последовательность элементами
        $index_of_member=2;
        for ($i=0;$i<$index_of_member;$i++)
        {
            $member=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
            $sequence->append($member);
        }
        $member_search=$this->getMock(\Aot\Sviaz\SequenceMember\Base::class);
        $this->assertEquals(null,$sequence->getPosition($member_search));
    }

    public function testGetId()
    {
        $sequence = \Aot\Sviaz\Sequence::create();///<Создаём последовательность
        PHPUnitHelper::setProtectedProperty($sequence,'id','test');
        $this->assertEquals('test',$sequence->getId());
    }

    public function testAddSviaz()
    {
        $sequence = \Aot\Sviaz\Sequence::create();///<Создаём последовательность
        $sviaz1 = $this->getMock(\Aot\Sviaz\Podchinitrelnaya\Base::class);
        $sviaz2 = $this->getMock(\Aot\Sviaz\Podchinitrelnaya\Base::class);
        $sequence->addSviaz($sviaz1);
        $sequence->addSviaz($sviaz2);
        $this->assertEquals(2,count($sequence->getSviazi()));
    }
}